#!/usr/bin/env ruby
#
# Copyright (C) Etolabo Corp. All rights reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.
#

begin
    require 'rubygems'
rescue LoadError
end
require 'msgpack'
require 'socket'


class KumoRPC
    def initialize(host, port)
        begin
            @sock = TCPSocket.open(host, port)
            @pk = MessagePack::Unpacker.new
            @buffer = ''
            @nread = 0
            @seqid = rand(1<<16)  # FIXME 1 << 32
            @callback = {}
        rescue => ex
            p ex
            exit 2
        end
    end

    def close
        @sock.close
    end

    private
    module MessageType
        Request     = 0
        Response    = 1
        ClusterInit = 2
    end

    def send_request(seq, cmd, param)
        @sock.write [MessageType::Request, seq, cmd, param].to_msgpack
        @sock.flush
    rescue
        @sock.close
        raise
    end

    def receive_message
        while true
            if @buffer.length > @nread
                @nread = @pk.execute(@buffer, @nread)
                if @pk.finished?
                    msg = @pk.data
                    @pk.reset
                    @buffer.slice!(0, @nread)
                    @nread = 0
                    if msg[0] == MessageType::Request
                        process_request(msg[1], msg[2], msg[3])
                    elsif msg[0] == MessageType::Response
                        process_response(msg[1], msg[3], msg[2])
                    else  # MessageType::ClusterInit
                        raise "unexpected cluster init message"
                    end
                    return msg[1]
                end
            end
            @buffer << @sock.sysread(1024)
        end
    end

    def process_request(seqid, cmd, param)
        #raise "request received, excpect response"
        # ignore it
    end

    def process_response(seqid, res, err)
        if cb = @callback[seqid]
            cb.call(res, err)
        end
    end

    def synchronize_response(seqid)
        while receive_message != seqid; end
    end

    def send_request_async(cmd, param, &callback)
        seqid = @seqid
        # FIXME 1 << 32
        @seqid += 1; if @seqid >= 1<<16 then @seqid = 0 end
        @callback[seqid] = callback if callback
        send_request(seqid, cmd, param)
        seqid
    end

    def send_request_sync(cmd, param)
        res = nil
        err = nil
        seqid = send_request_async(cmd, param) {|rres, rerr|
            res = rres
            err = rerr
        }
        synchronize_response(seqid)
        return [res, err]
    end

    def send_request_sync_ex(cmd, param)
        res, err = send_request_sync(cmd, param)
        raise "error #{err}" if err
        res
    end


    def rpc_addr(raw)
        if raw.length == 6
            addr = Socket.pack_sockaddr_in(0, '0.0.0.0')
            addr[2,6] = raw[0,6]
        else
            addr = Socket.pack_sockaddr_in(0, '::')
            addr[2,2]  = raw[0,2]
            addr[8,20] = raw[2,20]
        end
        Socket.unpack_sockaddr_in(addr).reverse
    end

    public
    def GetStatus
        res = send_request_sync_ex(Protocol::GetNodesInfo, [])
        form = {}
        nodes = res[0]

        clocktime = nodes.slice!(-1)
        date = Time.at(clocktime >> 32)
        clock = clocktime & ((1<<32)-1)

        nodes.each {|nodes|
            nodes.map! {|raw|
                active = (raw.slice!(0) == "\1"[0])
                rpc_addr(raw) << active
            }
        }

        newcomers = res[1]
        res[1].map! {|raw|
            rpc_addr(raw)
        }

        return [nodes, newcomers, date, clock]
    end

    module Protocol
        GetNodesInfo        = 0 << 16 |  99
        AttachNewServers    = 0 << 16 | 100
        DetachFaultServers  = 0 << 16 | 101
        CreateBackup        = 0 << 16 | 102
        SetAutoReplace      = 0 << 16 | 103
        StartReplace        = 0 << 16 | 104
        GetStatus           = 0 << 16 |  97
        SetConfig           = 0 << 16 |  98
    end

    MANAGER_DEFAULT_PORT = 19700
    SERVER_DEFAULT_PORT  = 19800
end


class KumoManager < KumoRPC
    def initialize(host, port)
        super(host, port)
    end
end

$now = Time.now.strftime("%Y%m%d")

def usage
    puts "Usage: #{File.basename($0)} address[:port=#{KumoRPC::MANAGER_DEFAULT_PORT}] command [options]"
    puts "command:"
    puts "   status                     get status"
    exit 1
end

if ARGV.length != 1
    usage
end

addr = ARGV.shift
host, port = addr.split(':', 2)
port ||= KumoRPC::MANAGER_DEFAULT_PORT

cmd = ARGV.shift

case cmd
when "stat", "status"
    usage if ARGV.length != 0
    attached, not_attached, date, clock =
        KumoManager.new(host, port).GetStatus
    puts "not attached node: #{not_attached.size}"
    puts "attached node    : #{attached.size}"
    puts "hash space timestamp: #{date} clock #{clock}"
    if not_attached.size == 0
        exit 0
    else
        exit 1
    end
else
    puts "unknown command #{cmd}"
    puts ""
    usage
end
